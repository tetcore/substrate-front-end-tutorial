{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _Struct = _interopRequireDefault(require(\"../../../codec/Struct\"));\n\nvar _Address = _interopRequireDefault(require(\"../../Address\"));\n\nvar _BalanceCompact = _interopRequireDefault(require(\"../../BalanceCompact\"));\n\nvar _Signature = _interopRequireDefault(require(\"../../Signature\"));\n\nvar _NonceCompact = _interopRequireDefault(require(\"../../../type/NonceCompact\"));\n\nvar _ExtrinsicEra = _interopRequireDefault(require(\"../ExtrinsicEra\"));\n\nvar _constants = require(\"../constants\");\n\nvar _SignaturePayload = _interopRequireDefault(require(\"./SignaturePayload\")); // Copyright 2017-2019 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n/**\n * @name ExtrinsicSignature\n * @description\n * A container for the [[Signature]] associated with a specific [[Extrinsic]]\n */\n\n\nclass ExtrinsicSignatureV1 extends _Struct.default {\n  // Signature Information.\n  //   1/3/5/9/33 bytes: The signing account identity, in Address format\n  //   64 bytes: The sr25519/ed25519 signature of the Signing Payload\n  //   1-8 bytes: The Compact<Nonce> of the signing account\n  //   1/2 bytes: The Transaction Era\n  constructor(value) {\n    let _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        isSigned = _ref3.isSigned;\n\n    super({\n      signer: _Address.default,\n      signature: _Signature.default,\n      nonce: _NonceCompact.default,\n      era: _ExtrinsicEra.default\n    }, ExtrinsicSignatureV1.decodeExtrinsicSignature(value, isSigned));\n  }\n\n  static decodeExtrinsicSignature(value) {\n    let isSigned = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (!value) {\n      return _constants.EMPTY_U8A;\n    } else if (value instanceof ExtrinsicSignatureV1) {\n      return value;\n    }\n\n    return isSigned ? value : _constants.EMPTY_U8A;\n  }\n  /**\n   * @description `true` if the signature is valid\n   */\n\n\n  get isSigned() {\n    return !this.signature.isEmpty;\n  }\n  /**\n   * @description The [[ExtrinsicEra]] (mortal or immortal) this signature applies to\n   */\n\n\n  get era() {\n    return this.get('era');\n  }\n  /**\n   * @description The [[Nonce]] for the signature\n   */\n\n\n  get nonce() {\n    return this.get('nonce');\n  }\n  /**\n   * @description The actuall [[Signature]] hash\n   */\n\n\n  get signature() {\n    return this.get('signature');\n  }\n  /**\n   * @description The [[Address]] that signed\n   */\n\n\n  get signer() {\n    return this.get('signer');\n  }\n  /**\n   * @description Forwards compat\n   */\n\n\n  get tip() {\n    return new _BalanceCompact.default(0);\n  }\n\n  injectSignature(signer, signature, _ref) {\n    let era = _ref.era,\n        nonce = _ref.nonce;\n    this.set('era', era);\n    this.set('nonce', nonce);\n    this.set('signer', signer);\n    this.set('signature', signature);\n    return this;\n  }\n  /**\n   * @description Adds a raw signature\n   */\n\n\n  addSignature(signer, signature, payload) {\n    return this.injectSignature(new _Address.default(signer), new _Signature.default(signature), new _SignaturePayload.default(payload));\n  }\n  /**\n   * @description Generate a payload and pplies the signature from a keypair\n   */\n\n\n  sign(method, account, _ref2) {\n    let blockHash = _ref2.blockHash,\n        era = _ref2.era,\n        nonce = _ref2.nonce;\n    const signer = new _Address.default(account.publicKey);\n    const payload = new _SignaturePayload.default({\n      nonce,\n      method: method.toU8a(),\n      era: era || _constants.IMMORTAL_ERA,\n      blockHash\n    });\n    const signature = new _Signature.default(payload.sign(account));\n    return this.injectSignature(signer, signature, payload);\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return this.isSigned ? super.toU8a(isBare) : new Uint8Array();\n  }\n\n}\n\nexports.default = ExtrinsicSignatureV1;","map":null,"metadata":{},"sourceType":"script"}