{"ast":null,"code":"/**\n\tC-like unsigned 32 bits integers in Javascript\n\tCopyright (C) 2013, Pierre Curto\n\tMIT license\n */\n;\n\n(function (root) {\n  // Local cache for typical radices\n  var radixPowerCache = {\n    36: UINT32(Math.pow(36, 5)),\n    16: UINT32(Math.pow(16, 7)),\n    10: UINT32(Math.pow(10, 9)),\n    2: UINT32(Math.pow(2, 30))\n  };\n  var radixCache = {\n    36: UINT32(36),\n    16: UINT32(16),\n    10: UINT32(10),\n    2: UINT32(2)\n    /**\n     *\tRepresents an unsigned 32 bits integer\n     * @constructor\n     * @param {Number|String|Number} low bits     | integer as a string \t\t | integer as a number\n     * @param {Number|Number|Undefined} high bits | radix (optional, default=10)\n     * @return \n     */\n\n  };\n\n  function UINT32(l, h) {\n    if (!(this instanceof UINT32)) return new UINT32(l, h);\n    this._low = 0;\n    this._high = 0;\n    this.remainder = null;\n    if (typeof h == 'undefined') return fromNumber.call(this, l);\n    if (typeof l == 'string') return fromString.call(this, l, h);\n    fromBits.call(this, l, h);\n  }\n  /**\n   * Set the current _UINT32_ object with its low and high bits\n   * @method fromBits\n   * @param {Number} low bits\n   * @param {Number} high bits\n   * @return ThisExpression\n   */\n\n\n  function fromBits(l, h) {\n    this._low = l | 0;\n    this._high = h | 0;\n    return this;\n  }\n\n  UINT32.prototype.fromBits = fromBits;\n  /**\n   * Set the current _UINT32_ object from a number\n   * @method fromNumber\n   * @param {Number} number\n   * @return ThisExpression\n   */\n\n  function fromNumber(value) {\n    this._low = value & 0xFFFF;\n    this._high = value >>> 16;\n    return this;\n  }\n\n  UINT32.prototype.fromNumber = fromNumber;\n  /**\n   * Set the current _UINT32_ object from a string\n   * @method fromString\n   * @param {String} integer as a string\n   * @param {Number} radix (optional, default=10)\n   * @return ThisExpression\n   */\n\n  function fromString(s, radix) {\n    var value = parseInt(s, radix || 10);\n    this._low = value & 0xFFFF;\n    this._high = value >>> 16;\n    return this;\n  }\n\n  UINT32.prototype.fromString = fromString;\n  /**\n   * Convert this _UINT32_ to a number\n   * @method toNumber\n   * @return {Number} the converted UINT32\n   */\n\n  UINT32.prototype.toNumber = function () {\n    return this._high * 65536 + this._low;\n  };\n  /**\n   * Convert this _UINT32_ to a string\n   * @method toString\n   * @param {Number} radix (optional, default=10)\n   * @return {String} the converted UINT32\n   */\n\n\n  UINT32.prototype.toString = function (radix) {\n    return this.toNumber().toString(radix || 10);\n  };\n  /**\n   * Add two _UINT32_. The current _UINT32_ stores the result\n   * @method add\n   * @param {Object} other UINT32\n   * @return ThisExpression\n   */\n\n\n  UINT32.prototype.add = function (other) {\n    var a00 = this._low + other._low;\n    var a16 = a00 >>> 16;\n    a16 += this._high + other._high;\n    this._low = a00 & 0xFFFF;\n    this._high = a16 & 0xFFFF;\n    return this;\n  };\n  /**\n   * Subtract two _UINT32_. The current _UINT32_ stores the result\n   * @method subtract\n   * @param {Object} other UINT32\n   * @return ThisExpression\n   */\n\n\n  UINT32.prototype.subtract = function (other) {\n    //TODO inline\n    return this.add(other.clone().negate());\n  };\n  /**\n   * Multiply two _UINT32_. The current _UINT32_ stores the result\n   * @method multiply\n   * @param {Object} other UINT32\n   * @return ThisExpression\n   */\n\n\n  UINT32.prototype.multiply = function (other) {\n    /*\n    \ta = a00 + a16\n    \tb = b00 + b16\n    \ta*b = (a00 + a16)(b00 + b16)\n    \t\t= a00b00 + a00b16 + a16b00 + a16b16\n    \t\ta16b16 overflows the 32bits\n     */\n    var a16 = this._high;\n    var a00 = this._low;\n    var b16 = other._high;\n    var b00 = other._low;\n    /* Removed to increase speed under normal circumstances (i.e. not multiplying by 0 or 1)\n    \t\t// this == 0 or other == 1: nothing to do\n    \t\tif ((a00 == 0 && a16 == 0) || (b00 == 1 && b16 == 0)) return this\n    \n    \t\t// other == 0 or this == 1: this = other\n    \t\tif ((b00 == 0 && b16 == 0) || (a00 == 1 && a16 == 0)) {\n    \t\t\tthis._low = other._low\n    \t\t\tthis._high = other._high\n    \t\t\treturn this\n    \t\t}\n    */\n\n    var c16, c00;\n    c00 = a00 * b00;\n    c16 = c00 >>> 16;\n    c16 += a16 * b00;\n    c16 &= 0xFFFF; // Not required but improves performance\n\n    c16 += a00 * b16;\n    this._low = c00 & 0xFFFF;\n    this._high = c16 & 0xFFFF;\n    return this;\n  };\n  /**\n   * Divide two _UINT32_. The current _UINT32_ stores the result.\n   * The remainder is made available as the _remainder_ property on\n   * the _UINT32_ object. It can be null, meaning there are no remainder.\n   * @method div\n   * @param {Object} other UINT32\n   * @return ThisExpression\n   */\n\n\n  UINT32.prototype.div = function (other) {\n    if (other._low == 0 && other._high == 0) throw Error('division by zero'); // other == 1\n\n    if (other._high == 0 && other._low == 1) {\n      this.remainder = new UINT32(0);\n      return this;\n    } // other > this: 0\n\n\n    if (other.gt(this)) {\n      this.remainder = this.clone();\n      this._low = 0;\n      this._high = 0;\n      return this;\n    } // other == this: 1\n\n\n    if (this.eq(other)) {\n      this.remainder = new UINT32(0);\n      this._low = 1;\n      this._high = 0;\n      return this;\n    } // Shift the divisor left until it is higher than the dividend\n\n\n    var _other = other.clone();\n\n    var i = -1;\n\n    while (!this.lt(_other)) {\n      // High bit can overflow the default 16bits\n      // Its ok since we right shift after this loop\n      // The overflown bit must be kept though\n      _other.shiftLeft(1, true);\n\n      i++;\n    } // Set the remainder\n\n\n    this.remainder = this.clone(); // Initialize the current result to 0\n\n    this._low = 0;\n    this._high = 0;\n\n    for (; i >= 0; i--) {\n      _other.shiftRight(1); // If shifted divisor is smaller than the dividend\n      // then subtract it from the dividend\n\n\n      if (!this.remainder.lt(_other)) {\n        this.remainder.subtract(_other); // Update the current result\n\n        if (i >= 16) {\n          this._high |= 1 << i - 16;\n        } else {\n          this._low |= 1 << i;\n        }\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Negate the current _UINT32_\n   * @method negate\n   * @return ThisExpression\n   */\n\n\n  UINT32.prototype.negate = function () {\n    var v = (~this._low & 0xFFFF) + 1;\n    this._low = v & 0xFFFF;\n    this._high = ~this._high + (v >>> 16) & 0xFFFF;\n    return this;\n  };\n  /**\n   * Equals\n   * @method eq\n   * @param {Object} other UINT32\n   * @return {Boolean}\n   */\n\n\n  UINT32.prototype.equals = UINT32.prototype.eq = function (other) {\n    return this._low == other._low && this._high == other._high;\n  };\n  /**\n   * Greater than (strict)\n   * @method gt\n   * @param {Object} other UINT32\n   * @return {Boolean}\n   */\n\n\n  UINT32.prototype.greaterThan = UINT32.prototype.gt = function (other) {\n    if (this._high > other._high) return true;\n    if (this._high < other._high) return false;\n    return this._low > other._low;\n  };\n  /**\n   * Less than (strict)\n   * @method lt\n   * @param {Object} other UINT32\n   * @return {Boolean}\n   */\n\n\n  UINT32.prototype.lessThan = UINT32.prototype.lt = function (other) {\n    if (this._high < other._high) return true;\n    if (this._high > other._high) return false;\n    return this._low < other._low;\n  };\n  /**\n   * Bitwise OR\n   * @method or\n   * @param {Object} other UINT32\n   * @return ThisExpression\n   */\n\n\n  UINT32.prototype.or = function (other) {\n    this._low |= other._low;\n    this._high |= other._high;\n    return this;\n  };\n  /**\n   * Bitwise AND\n   * @method and\n   * @param {Object} other UINT32\n   * @return ThisExpression\n   */\n\n\n  UINT32.prototype.and = function (other) {\n    this._low &= other._low;\n    this._high &= other._high;\n    return this;\n  };\n  /**\n   * Bitwise NOT\n   * @method not\n   * @return ThisExpression\n   */\n\n\n  UINT32.prototype.not = function () {\n    this._low = ~this._low & 0xFFFF;\n    this._high = ~this._high & 0xFFFF;\n    return this;\n  };\n  /**\n   * Bitwise XOR\n   * @method xor\n   * @param {Object} other UINT32\n   * @return ThisExpression\n   */\n\n\n  UINT32.prototype.xor = function (other) {\n    this._low ^= other._low;\n    this._high ^= other._high;\n    return this;\n  };\n  /**\n   * Bitwise shift right\n   * @method shiftRight\n   * @param {Number} number of bits to shift\n   * @return ThisExpression\n   */\n\n\n  UINT32.prototype.shiftRight = UINT32.prototype.shiftr = function (n) {\n    if (n > 16) {\n      this._low = this._high >> n - 16;\n      this._high = 0;\n    } else if (n == 16) {\n      this._low = this._high;\n      this._high = 0;\n    } else {\n      this._low = this._low >> n | this._high << 16 - n & 0xFFFF;\n      this._high >>= n;\n    }\n\n    return this;\n  };\n  /**\n   * Bitwise shift left\n   * @method shiftLeft\n   * @param {Number} number of bits to shift\n   * @param {Boolean} allow overflow\n   * @return ThisExpression\n   */\n\n\n  UINT32.prototype.shiftLeft = UINT32.prototype.shiftl = function (n, allowOverflow) {\n    if (n > 16) {\n      this._high = this._low << n - 16;\n      this._low = 0;\n\n      if (!allowOverflow) {\n        this._high &= 0xFFFF;\n      }\n    } else if (n == 16) {\n      this._high = this._low;\n      this._low = 0;\n    } else {\n      this._high = this._high << n | this._low >> 16 - n;\n      this._low = this._low << n & 0xFFFF;\n\n      if (!allowOverflow) {\n        // Overflow only allowed on the high bits...\n        this._high &= 0xFFFF;\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Bitwise rotate left\n   * @method rotl\n   * @param {Number} number of bits to rotate\n   * @return ThisExpression\n   */\n\n\n  UINT32.prototype.rotateLeft = UINT32.prototype.rotl = function (n) {\n    var v = this._high << 16 | this._low;\n    v = v << n | v >>> 32 - n;\n    this._low = v & 0xFFFF;\n    this._high = v >>> 16;\n    return this;\n  };\n  /**\n   * Bitwise rotate right\n   * @method rotr\n   * @param {Number} number of bits to rotate\n   * @return ThisExpression\n   */\n\n\n  UINT32.prototype.rotateRight = UINT32.prototype.rotr = function (n) {\n    var v = this._high << 16 | this._low;\n    v = v >>> n | v << 32 - n;\n    this._low = v & 0xFFFF;\n    this._high = v >>> 16;\n    return this;\n  };\n  /**\n   * Clone the current _UINT32_\n   * @method clone\n   * @return {Object} cloned UINT32\n   */\n\n\n  UINT32.prototype.clone = function () {\n    return new UINT32(this._low, this._high);\n  };\n\n  if (typeof define != 'undefined' && define.amd) {\n    // AMD / RequireJS\n    define([], function () {\n      return UINT32;\n    });\n  } else if (typeof module != 'undefined' && module.exports) {\n    // Node.js\n    module.exports = UINT32;\n  } else {\n    // Browser\n    root['UINT32'] = UINT32;\n  }\n})(this);","map":null,"metadata":{},"sourceType":"script"}